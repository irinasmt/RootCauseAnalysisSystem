# Data Models (Concrete Specs)

This doc defines the **minimum** concrete schemas needed to build the Brain and UI.

Design goals
- Stable IDs everywhere
- Append-only where feasible (events, metrics)
- Evidence is stored as **references** (queries, artifacts, snapshots), not hand-wavy text

---

## Canonical IDs

- `service_id`: stable logical service identity
- `incident_id`: one investigation unit (candidate or approved)
- `deployment_event_id`: one rollout event
- `commit_sha`: git SHA-1/2 (string)
- `evidence_id`: one evidence artifact or query reference

---

## PostgreSQL (app state)

Postgres holds the “system of record” for incidents, decisions, and report artifacts.

### Suggested tables (DDL sketch)

```sql
-- Services
CREATE TABLE services (
  service_id UUID PRIMARY KEY,
  cluster_id TEXT NOT NULL,
  namespace TEXT NOT NULL,
  service_name TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(cluster_id, namespace, service_name)
);

-- Deployment events
CREATE TABLE deployment_events (
  deployment_event_id UUID PRIMARY KEY,
  service_id UUID NOT NULL REFERENCES services(service_id),
  started_at TIMESTAMPTZ NOT NULL,
  finished_at TIMESTAMPTZ,
  deploy_type TEXT NOT NULL, -- helm|k8s|argo|flux|manual|other
  image_ref TEXT,
  revision TEXT,            -- best-effort commit SHA or build ID; null for manual changes
  metadata JSONB NOT NULL DEFAULT '{}'::jsonb
);

-- Config change events (out-of-band mutations: manual kubectl, DB schema changes, ConfigMap/Secret edits)
-- Every change that has no git trail still gets an event here so the correlator can use timing.
CREATE TABLE config_change_events (
  config_change_id UUID PRIMARY KEY,
  service_id UUID REFERENCES services(service_id), -- null if cluster-wide
  detected_at TIMESTAMPTZ NOT NULL,
  source TEXT NOT NULL,        -- k8s_deployment|k8s_configmap|k8s_secret|k8s_replicaset|db_schema
  change_kind TEXT NOT NULL,   -- image_swap|env_var|resource_limit|replica_count|configmap_key|secret_key|db_schema_alter
  resource_name TEXT NOT NULL, -- e.g. deployment name, configmap name, table name
  diff_payload JSONB NOT NULL, -- structured diff: { field, old_value, new_value } — never store secret values
  actor TEXT,                  -- populated only if K8s audit logging is enabled
  audit_log_ref TEXT           -- optional pointer to raw audit log entry
);

CREATE INDEX config_change_events_service_time ON config_change_events(service_id, detected_at);

-- Incidents
CREATE TABLE incidents (
  incident_id UUID PRIMARY KEY,
  service_id UUID NOT NULL REFERENCES services(service_id),
  status TEXT NOT NULL, -- open|triaged|resolved|suppressed
  trigger_type TEXT NOT NULL, -- error_rate_spike|p99_regression|crashloop|custom
  severity INT NOT NULL,
  window_start TIMESTAMPTZ NOT NULL,
  window_end TIMESTAMPTZ NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Trigger / gating decisions
CREATE TABLE incident_decisions (
  decision_id UUID PRIMARY KEY,
  incident_id UUID NOT NULL REFERENCES incidents(incident_id),
  decided_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  decision TEXT NOT NULL, -- approved|suppressed
  rationale TEXT NOT NULL,
  policy_version TEXT NOT NULL,
  details JSONB NOT NULL DEFAULT '{}'::jsonb
);

-- Evidence artifacts (query refs, charts, snapshots)
CREATE TABLE evidence_artifacts (
  evidence_id UUID PRIMARY KEY,
  incident_id UUID NOT NULL REFERENCES incidents(incident_id),
  kind TEXT NOT NULL, -- clickhouse_query|prom_query|k8s_event|git_diff|snapshot|note
  source TEXT NOT NULL, -- clickhouse|prometheus|k8s|github|manual
  ref TEXT NOT NULL,    -- query_id, URL, object key, etc.
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  metadata JSONB NOT NULL DEFAULT '{}'::jsonb
);

-- Hypotheses and final report
CREATE TABLE incident_hypotheses (
  hypothesis_id UUID PRIMARY KEY,
  incident_id UUID NOT NULL REFERENCES incidents(incident_id),
  rank INT NOT NULL,
  hypothesis_type TEXT NOT NULL, -- release|traffic|dependency|db|infra|unknown
  title TEXT NOT NULL,
  confidence NUMERIC(3,2) NOT NULL,
  evidence_ids UUID[] NOT NULL,
  details JSONB NOT NULL DEFAULT '{}'::jsonb
);

CREATE TABLE incident_reports (
  report_id UUID PRIMARY KEY,
  incident_id UUID NOT NULL REFERENCES incidents(incident_id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  model_info JSONB NOT NULL DEFAULT '{}'::jsonb,
  report_markdown TEXT NOT NULL,
  evidence_ids UUID[] NOT NULL
);

-- Commits (pre-computed at push time via webhook)
CREATE TABLE commits (
  commit_sha TEXT PRIMARY KEY,
  repo TEXT NOT NULL,
  author TEXT,
  message TEXT NOT NULL,
  summary TEXT,                -- generated by local LLM at push time
  authored_at TIMESTAMPTZ NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Per-file records for each commit (change type + stored diff)
CREATE TABLE commit_files (
  id UUID PRIMARY KEY,
  commit_sha TEXT NOT NULL REFERENCES commits(commit_sha),
  file_path TEXT NOT NULL,
  change_type TEXT NOT NULL,   -- db_migration|dependency|config|timeout_retry|http_client|shared_util|auth|test|docs|other
  diff_text TEXT,              -- raw diff hunk stored for on-demand retrieval
  lines_added INT NOT NULL DEFAULT 0,
  lines_removed INT NOT NULL DEFAULT 0
);

CREATE INDEX commit_files_sha_type ON commit_files(commit_sha, change_type);

-- Links a deployment to its commit range
CREATE TABLE deployment_commit_ranges (
  deployment_event_id UUID PRIMARY KEY REFERENCES deployment_events(deployment_event_id),
  previous_revision TEXT,      -- null = unknown; fall back to last N commits
  current_revision TEXT NOT NULL,
  is_rollback BOOLEAN NOT NULL DEFAULT false,
  commit_shas TEXT[] NOT NULL DEFAULT '{}'
);

-- Human feedback (append-only)
CREATE TABLE feedback_events (
  feedback_event_id UUID PRIMARY KEY,
  incident_id UUID NOT NULL REFERENCES incidents(incident_id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  actor_type TEXT NOT NULL,  -- user|system|integration
  actor_id TEXT,             -- optional (future: user_id)
  event_type TEXT NOT NULL,  -- hypothesis_confirmed|hypothesis_rejected|root_cause_set|human_note_added|...
  payload JSONB NOT NULL DEFAULT '{}'::jsonb
);

-- Optional convenience fields (derived from feedback_events)
-- If you want to store a resolved outcome directly, keep it consistent with the event log.
ALTER TABLE incidents
  ADD COLUMN resolved_at TIMESTAMPTZ,
  ADD COLUMN resolution_kind TEXT,      -- hypothesis|other|unknown
  ADD COLUMN resolution_summary TEXT,
  ADD COLUMN resolved_hypothesis_id UUID;

ALTER TABLE incidents
  ADD CONSTRAINT resolved_hypothesis_fk
  FOREIGN KEY (resolved_hypothesis_id) REFERENCES incident_hypotheses(hypothesis_id);
```

Notes
- Keep `evidence_artifacts.ref` flexible; it can be a ClickHouse query ID, Prometheus query string hash, S3 key, etc.
- Store *both* hypotheses list and final report markdown; UI needs both.

Human feedback notes
- Use `feedback_events` as the source of truth for confirmations/rejections and final resolution.
- Prefer append-only events over mutable fields; if you add convenience resolution columns on `incidents`, they should be derived from events.

---

## ClickHouse (metrics + derived features)

ClickHouse stores time-series points and derived anomaly features.

### Minimal metrics table (DDL sketch)

```sql
CREATE TABLE metric_points (
  ts DateTime64(3, 'UTC'),
  service_key String,             -- e.g., cluster/namespace/service
  metric_name LowCardinality(String),
  value Float64,
  labels Map(String, String)
)
ENGINE = MergeTree
PARTITION BY toDate(ts)
ORDER BY (service_key, metric_name, ts);
```

### Derived anomaly features (DDL sketch)

```sql
CREATE TABLE anomaly_features (
  incident_id String,
  ts DateTime64(3, 'UTC'),
  service_key String,
  feature_name LowCardinality(String),
  feature_value Float64
)
ENGINE = MergeTree
PARTITION BY toDate(ts)
ORDER BY (incident_id, feature_name, ts);
```

---

## Neo4j (topology + relationships)

Neo4j captures relationships to support queries like:
- “what downstream deps could explain this?”
- “which commits touched services in this blast radius?”

### Node labels
- `Service {service_key, cluster_id, namespace, name}`
- `Deployment {deployment_event_id, started_at, image_ref, revision}`
- `Commit {sha, repo, authored_at}`
- `Dependency {name, kind}` (service→service or service→external)
- `Database {name, engine}`

### Relationship types
- `(Service)-[:DEPENDS_ON]->(Dependency|Service|Database)`
- `(Service)-[:DEPLOYED_AS]->(Deployment)`
- `(Deployment)-[:BUILT_FROM]->(Commit)` (best-effort)
- `(Commit)-[:TOUCHED]->(Service)` (optional, derived)

### Constraints (Cypher sketch)

```cypher
CREATE CONSTRAINT service_key IF NOT EXISTS
FOR (s:Service) REQUIRE s.service_key IS UNIQUE;

CREATE CONSTRAINT commit_sha IF NOT EXISTS
FOR (c:Commit) REQUIRE c.sha IS UNIQUE;
```

---

## Qdrant (semantic retrieval)

Qdrant stores embeddings for text chunks with payload metadata.

### Collections

1) `git_diff_chunks`
- Vector: embedding dimension per model (e.g., 1536/3072/etc.)
- Payload:
  - `repo`, `sha`, `path`, `hunk_id`
  - `authored_at`, `deployment_event_id` (optional)

2) `runbooks`
- Payload:
  - `title`, `service_key` (optional), `tags`, `source_url`

3) `incident_summaries`
- Payload:
  - `incident_id`, `service_key`, `started_at`, `resolved_at`

### Retrieval contract

Every retrieval result must be convertible into an `evidence_artifacts` record:
- `source = qdrant`
- `ref = <collection>/<point_id>`
- `metadata` includes payload + similarity score
